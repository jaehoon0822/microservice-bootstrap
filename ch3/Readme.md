# 마이크로 서비스 게시

이 책에서의 운영환경은 `Kubertetes` 이다.  
이를 위해서는 `Docker` 를 컨테이너화 시켜서 만든다.

`Docker` 를 사용하여 `code`, `relative file`, `dependancy` 를 하나의  
`bundle package(image)` 로 만들어 `container registry` 에 저장한다.

이후에 `container registry` 에서 `image` 를 `pull` 하여 사용하도록 만든다.

이책에서는 `Azure` 를 사용하여 서비스를 만드는데,  
개인적으로 `AWS` 였으면 좋았겠다 싶지만, 일단은 따라가자..

## Docker

> 마이크로서비스를 패키징하고, 게시 및 테스트를 하기 위해 사용

### 컨테이너의 개념

> 컨테이너는 일종의 서버 가상화 방법이다.

---

- 가상머신과 컨테이너의 차이에 대해서 (내가 이해한것)

> 가상머신은 `가상화된 하드웨어위에 운영체제를 설치` 하여 작동한다.
> 이때 `guest os 커널` 이 `하드웨어` 에 작동명령을 주는데,  
> `os` 마다 `커널` 이 변환한 `명령어` 가 다르다.  
> 이를 해결하기 위해 중간에 `하이퍼바이저` 를 사용한다.
> 하이퍼바이저는 `guest os 커널` 의 `명령어` 를 `host os` 커널의 `명령어` 로 변환하여 `하드웨어` 에 명령을 전달한다.
>
> > `guest os` 에 `가상화된 하드웨어` 가 있더라도 실제적으로 작동하는것은  
> > `host os` 의 `실제 하드웨어이`다. 실제 하드웨어위에 있는 `os`는  
> > `host os` 이므로, `host os` 의 `커널 명령어` 로 변환해야 한다.
>
> 컨테이너는 `하이퍼바이저` 가 존재하지 않으며, `host os` 커널상에서
> 작동한다. `하이퍼바이저` 대신 `dockerd` 가 `CGroups` 와 `namespace` 를 사용하여, 컨테이너를 격리시키고, 자원을 제한하도록 만들어 처리한다.
>
> 이는 마치 `Native Application` 처럼 작동한다.
> 당연, `하이퍼바이저` 에 의한 번역과정이 없으므로 더 나은 성능을 보여주며 가볍다.

### 이미지의 개념

> 이미지는 부팅이 가능한 서버의 스냅샷이며, 모든 코드, 종속성 및 실행에  
> 필요한 관련 파일들을 포함한다.

마치 `image` 는 `class` 와 비슷하고, `container` 는 `instance` 와 비슷하다.

객체지향 에서 `class`에 대해서 가장 많이 비유하는 것으로 말하자면,
`image` 는 붕어빵틀이고, `container` 는 붕어빵이다.

단, `code를 캡슐화` 한것이 아닌 `코드 및 종속성을 캡슐화한 가상화된 os`를 가진 붕어빵 틀 일뿐이다.

### 도커를 사용하는 이유

`도커는 마이크로 서비스 패키지를 만들고 게시하는 도구이다.`  
`도커를 가지고 우리가 작업한 것들을 패키징하고 게시하는데 사용된다.`

> - 시스템 환경 표준화
>   도커는 시스템 환경을 표준화 할수 있는 좋은 도구이다.  
>   모든 개발자들이 동일한 개발 환경을 가지고 작업할 수 있게 해준다.

마이크로 서비스를 만들기 위한 `flow` 는 다음과 같다

```sh

| < 서비스 >        | ---> | < 컨테이너 레지스트리 >   | ---> | <클러스터> |
| docker image 생성 |      | 서비스 도커 이미지 저장소 |      | 컨테이너들 |

```

각 `서비스` 는 `docker` 로 `image` 를 생성하고,
`컨테이너 레지스트리` 에 저장한다.

이후, `Kubernetes` 를 사용하여 `클러스터` 에서 각 컨테이너를 실행시키도록 한다.

> `Alpine` 과 `non-alpine` 의 비교
>
> 이미지 이름에 `alpine` 이 있다면 해당 이미지는 알파인 리눅스를 기반으로  
> 한다는것을 의미한다.
>
> 알파인은 **_최소한의 구성 요소만 가지고 있는 가벼운 리눅스이다._** 인프라와 클라우드 자원을 적게 사용 할수 있기 때문에 운영환경에 적합하다.
